import os
import cv2
import numpy as np
import matplotlib.pyplot as plt
import tensorflow as tf
from keras.preprocessing.image import ImageDataGenerator
from keras.applications import InceptionV3
from keras.applications.vgg16 import VGG16
from keras.applications.efficientnet import EfficientNetB4
from keras import Model, Sequential
from keras.layers import Input,Conv2D,Activation,MaxPool2D,Dense,Dropout,GlobalAveragePooling2D,BatchNormalization,Flatten
from keras.optimizers import Adam, SGD
from keras.callbacks import EarlyStopping
from keras.backend import clear_session
from keras.utils import plot_model

# import cv2
# import os
# import pandas as pd
#
#
# def convert_videos_to_frames_from_csv(csv_path, output_folder):
#     # Read the CSV file
#     df = pd.read_csv(csv_path)
#
#     # Create output folder if it doesn't exist
#     if not os.path.exists(output_folder):
#         os.makedirs(output_folder)
#
#     # Iterate through each row in the CSV file
#     for index, row in df.iterrows():
#         video_path = row['video_name']
#         label = row['tag']  # Assuming 'label' column specifies the folder name ('20foul' or 'normal')
#
#         # Process the video
#         convert_video_to_frames(video_path, output_folder, label)
#
#
# def convert_video_to_frames(video_path, output_folder, label):
#     # Open the video file
#     cap = cv2.VideoCapture(video_path)
#
#     # Create a subfolder in the output folder based on the label ('20foul' or 'normal')
#     video_name = os.path.splitext(os.path.basename(video_path))[0]
#     video_output_folder = os.path.join(output_folder, label, video_name)
#     os.makedirs(video_output_folder, exist_ok=True)
#
#     # Read frames from the video
#     frame_count = 0
#     while True:
#         ret, frame = cap.read()
#
#         if not ret:
#             break
#
#         # Save frame to video-specific output subfolder
#         frame_filename = os.path.join(video_output_folder, f"frame_{frame_count:04d}.jpg")
#         cv2.imwrite(frame_filename, frame)
#
#         frame_count += 1
#
#     # Release the video capture object
#     cap.release()
#
#     print(f"{frame_count} frames extracted and saved to {video_output_folder}")
#
#
# # Example usage
# csv_path = "data.csv"
# output_folder = "D:/college/grad. project/normal&foul_binaryClassifier/videos/test/output"
# convert_videos_to_frames_from_csv(csv_path, output_folder)

#data path
data_path = "D:/college/grad. project/normal&foul_binaryClassifier/videos/test/output/yooh"
output_path = "/kaggle/working"
input_shape = (256,256)
#preperation

datagen=ImageDataGenerator(rescale=1./255,validation_split=0.2,brightness_range=[1.2,2] ,horizontal_flip=True,vertical_flip=True,rotation_range=90)
train_data=datagen.flow_from_directory(data_path,batch_size=32,class_mode='binary',subset='training',target_size=input_shape)
val_data=datagen.flow_from_directory(data_path,batch_size=32,class_mode='binary',subset='validation',target_size=input_shape)
print(train_data.class_indices)
print(val_data.class_indices)

# Creating model from scratch:
inputs=Input(shape=(256,256,3))
#Initial Layers of 256 Filters
x = Conv2D(64,5,padding='same')(inputs)
x = Activation(activation='relu')(x)
x = MaxPool2D(strides=(2,2))(x)
x = Conv2D(64,5,padding='same')(inputs)
x = Activation(activation='relu')(x)
x = MaxPool2D(strides=(2,2))(x)
x = Conv2D(64,5,padding='same')(x)
x = Activation(activation='relu')(x)
x = MaxPool2D(strides=(2,2))(x)
x = Conv2D(64,5,padding='same')(x)
x = Activation(activation='relu')(x)
x = MaxPool2D(strides=(2,2))(x)

 #Decreasing Filters and MAxPool Layers
x = Conv2D(32,3,padding='same',dilation_rate=2)(x)
x = Activation(activation='relu')(x)
# x = BatchNormalization()(x)
x = MaxPool2D(strides=(2,2))(x)
x = Conv2D(16,3,padding='same',dilation_rate=2)(x)
x = Activation(activation='relu')(x)
x = MaxPool2D(strides=(2,2))(x)
# x = BatchNormalization()(x)
x = Conv2D(16,3,padding='same',dilation_rate=2)(x)
x = Activation(activation='relu')(x)
x = MaxPool2D(strides=(2,2))(x)

 #Dense Layers
x = GlobalAveragePooling2D()(x)
x = Flatten()(x)
x = Dense(400)(x)
x = Dropout(0.5)(x)
x = Activation(activation='relu')(x)
x = Dense(512)(x)
x = Dropout(0.5)(x)
x = Activation(activation='relu')(x)
x = Dense(400)(x)
x = Dropout(0.5)(x)
x = Activation(activation='relu')(x)
x = Dense(1)(x)

#Output
out = Activation(activation='sigmoid')(x)

# final model:
model = Model(inputs,out,name='BaseModel')

model.compile(loss='binary_crossentropy', optimizer=Adam(learning_rate=0.001), metrics=['accuracy'])

# training model:
es=EarlyStopping(monitor='val_accuracy',patience=7,verbose=0,restore_best_weights=True)
logs=model.fit(train_data,validation_data=val_data,epochs=15,callbacks=[es])

model.evaluate(val_data)
